// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'pubspec_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;
PubSpec _$PubSpecFromJson(Map<String, dynamic> json) {
  return _Pubspec.fromJson(json);
}

/// @nodoc
class _$PubSpecTearOff {
  const _$PubSpecTearOff();

// ignore: unused_element
  _Pubspec call(
      {Map<String, dynamic> dependencies,
      Map<String, dynamic> dependencyOverrides,
      String description,
      Map<String, dynamic> devDependencies,
      String documentation,
      Map<String, String> environment,
      Map<String, dynamic> executables,
      String homepage,
      String issueTracker,
      String name,
      String publishTo,
      String repository,
      String version}) {
    return _Pubspec(
      dependencies: dependencies,
      dependencyOverrides: dependencyOverrides,
      description: description,
      devDependencies: devDependencies,
      documentation: documentation,
      environment: environment,
      executables: executables,
      homepage: homepage,
      issueTracker: issueTracker,
      name: name,
      publishTo: publishTo,
      repository: repository,
      version: version,
    );
  }

// ignore: unused_element
  PubSpec fromJson(Map<String, Object> json) {
    return PubSpec.fromJson(json);
  }
}

/// @nodoc
// ignore: unused_element
const $PubSpec = _$PubSpecTearOff();

/// @nodoc
mixin _$PubSpec {
  Map<String, dynamic> get dependencies;
  Map<String, dynamic> get dependencyOverrides;
  String get description;
  Map<String, dynamic> get devDependencies;
  String get documentation;
  Map<String, String> get environment;
  Map<String, dynamic> get executables;
  String get homepage;
  String get issueTracker;
  String get name;
  String get publishTo;
  String get repository;
  String get version;

  Map<String, dynamic> toJson();
  $PubSpecCopyWith<PubSpec> get copyWith;
}

/// @nodoc
abstract class $PubSpecCopyWith<$Res> {
  factory $PubSpecCopyWith(PubSpec value, $Res Function(PubSpec) then) =
      _$PubSpecCopyWithImpl<$Res>;
  $Res call(
      {Map<String, dynamic> dependencies,
      Map<String, dynamic> dependencyOverrides,
      String description,
      Map<String, dynamic> devDependencies,
      String documentation,
      Map<String, String> environment,
      Map<String, dynamic> executables,
      String homepage,
      String issueTracker,
      String name,
      String publishTo,
      String repository,
      String version});
}

/// @nodoc
class _$PubSpecCopyWithImpl<$Res> implements $PubSpecCopyWith<$Res> {
  _$PubSpecCopyWithImpl(this._value, this._then);

  final PubSpec _value;
  // ignore: unused_field
  final $Res Function(PubSpec) _then;

  @override
  $Res call({
    Object dependencies = freezed,
    Object dependencyOverrides = freezed,
    Object description = freezed,
    Object devDependencies = freezed,
    Object documentation = freezed,
    Object environment = freezed,
    Object executables = freezed,
    Object homepage = freezed,
    Object issueTracker = freezed,
    Object name = freezed,
    Object publishTo = freezed,
    Object repository = freezed,
    Object version = freezed,
  }) {
    return _then(_value.copyWith(
      dependencies: dependencies == freezed
          ? _value.dependencies
          : dependencies as Map<String, dynamic>,
      dependencyOverrides: dependencyOverrides == freezed
          ? _value.dependencyOverrides
          : dependencyOverrides as Map<String, dynamic>,
      description:
          description == freezed ? _value.description : description as String,
      devDependencies: devDependencies == freezed
          ? _value.devDependencies
          : devDependencies as Map<String, dynamic>,
      documentation: documentation == freezed
          ? _value.documentation
          : documentation as String,
      environment: environment == freezed
          ? _value.environment
          : environment as Map<String, String>,
      executables: executables == freezed
          ? _value.executables
          : executables as Map<String, dynamic>,
      homepage: homepage == freezed ? _value.homepage : homepage as String,
      issueTracker: issueTracker == freezed
          ? _value.issueTracker
          : issueTracker as String,
      name: name == freezed ? _value.name : name as String,
      publishTo: publishTo == freezed ? _value.publishTo : publishTo as String,
      repository:
          repository == freezed ? _value.repository : repository as String,
      version: version == freezed ? _value.version : version as String,
    ));
  }
}

/// @nodoc
abstract class _$PubspecCopyWith<$Res> implements $PubSpecCopyWith<$Res> {
  factory _$PubspecCopyWith(_Pubspec value, $Res Function(_Pubspec) then) =
      __$PubspecCopyWithImpl<$Res>;
  @override
  $Res call(
      {Map<String, dynamic> dependencies,
      Map<String, dynamic> dependencyOverrides,
      String description,
      Map<String, dynamic> devDependencies,
      String documentation,
      Map<String, String> environment,
      Map<String, dynamic> executables,
      String homepage,
      String issueTracker,
      String name,
      String publishTo,
      String repository,
      String version});
}

/// @nodoc
class __$PubspecCopyWithImpl<$Res> extends _$PubSpecCopyWithImpl<$Res>
    implements _$PubspecCopyWith<$Res> {
  __$PubspecCopyWithImpl(_Pubspec _value, $Res Function(_Pubspec) _then)
      : super(_value, (v) => _then(v as _Pubspec));

  @override
  _Pubspec get _value => super._value as _Pubspec;

  @override
  $Res call({
    Object dependencies = freezed,
    Object dependencyOverrides = freezed,
    Object description = freezed,
    Object devDependencies = freezed,
    Object documentation = freezed,
    Object environment = freezed,
    Object executables = freezed,
    Object homepage = freezed,
    Object issueTracker = freezed,
    Object name = freezed,
    Object publishTo = freezed,
    Object repository = freezed,
    Object version = freezed,
  }) {
    return _then(_Pubspec(
      dependencies: dependencies == freezed
          ? _value.dependencies
          : dependencies as Map<String, dynamic>,
      dependencyOverrides: dependencyOverrides == freezed
          ? _value.dependencyOverrides
          : dependencyOverrides as Map<String, dynamic>,
      description:
          description == freezed ? _value.description : description as String,
      devDependencies: devDependencies == freezed
          ? _value.devDependencies
          : devDependencies as Map<String, dynamic>,
      documentation: documentation == freezed
          ? _value.documentation
          : documentation as String,
      environment: environment == freezed
          ? _value.environment
          : environment as Map<String, String>,
      executables: executables == freezed
          ? _value.executables
          : executables as Map<String, dynamic>,
      homepage: homepage == freezed ? _value.homepage : homepage as String,
      issueTracker: issueTracker == freezed
          ? _value.issueTracker
          : issueTracker as String,
      name: name == freezed ? _value.name : name as String,
      publishTo: publishTo == freezed ? _value.publishTo : publishTo as String,
      repository:
          repository == freezed ? _value.repository : repository as String,
      version: version == freezed ? _value.version : version as String,
    ));
  }
}

@JsonSerializable(fieldRename: FieldRename.snake)

/// @nodoc
class _$_Pubspec implements _Pubspec {
  _$_Pubspec(
      {this.dependencies,
      this.dependencyOverrides,
      this.description,
      this.devDependencies,
      this.documentation,
      this.environment,
      this.executables,
      this.homepage,
      this.issueTracker,
      this.name,
      this.publishTo,
      this.repository,
      this.version});

  factory _$_Pubspec.fromJson(Map<String, dynamic> json) =>
      _$_$_PubspecFromJson(json);

  @override
  final Map<String, dynamic> dependencies;
  @override
  final Map<String, dynamic> dependencyOverrides;
  @override
  final String description;
  @override
  final Map<String, dynamic> devDependencies;
  @override
  final String documentation;
  @override
  final Map<String, String> environment;
  @override
  final Map<String, dynamic> executables;
  @override
  final String homepage;
  @override
  final String issueTracker;
  @override
  final String name;
  @override
  final String publishTo;
  @override
  final String repository;
  @override
  final String version;

  @override
  String toString() {
    return 'PubSpec(dependencies: $dependencies, dependencyOverrides: $dependencyOverrides, description: $description, devDependencies: $devDependencies, documentation: $documentation, environment: $environment, executables: $executables, homepage: $homepage, issueTracker: $issueTracker, name: $name, publishTo: $publishTo, repository: $repository, version: $version)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Pubspec &&
            (identical(other.dependencies, dependencies) ||
                const DeepCollectionEquality()
                    .equals(other.dependencies, dependencies)) &&
            (identical(other.dependencyOverrides, dependencyOverrides) ||
                const DeepCollectionEquality()
                    .equals(other.dependencyOverrides, dependencyOverrides)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.devDependencies, devDependencies) ||
                const DeepCollectionEquality()
                    .equals(other.devDependencies, devDependencies)) &&
            (identical(other.documentation, documentation) ||
                const DeepCollectionEquality()
                    .equals(other.documentation, documentation)) &&
            (identical(other.environment, environment) ||
                const DeepCollectionEquality()
                    .equals(other.environment, environment)) &&
            (identical(other.executables, executables) ||
                const DeepCollectionEquality()
                    .equals(other.executables, executables)) &&
            (identical(other.homepage, homepage) ||
                const DeepCollectionEquality()
                    .equals(other.homepage, homepage)) &&
            (identical(other.issueTracker, issueTracker) ||
                const DeepCollectionEquality()
                    .equals(other.issueTracker, issueTracker)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.publishTo, publishTo) ||
                const DeepCollectionEquality()
                    .equals(other.publishTo, publishTo)) &&
            (identical(other.repository, repository) ||
                const DeepCollectionEquality()
                    .equals(other.repository, repository)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality().equals(other.version, version)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(dependencies) ^
      const DeepCollectionEquality().hash(dependencyOverrides) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(devDependencies) ^
      const DeepCollectionEquality().hash(documentation) ^
      const DeepCollectionEquality().hash(environment) ^
      const DeepCollectionEquality().hash(executables) ^
      const DeepCollectionEquality().hash(homepage) ^
      const DeepCollectionEquality().hash(issueTracker) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(publishTo) ^
      const DeepCollectionEquality().hash(repository) ^
      const DeepCollectionEquality().hash(version);

  @override
  _$PubspecCopyWith<_Pubspec> get copyWith =>
      __$PubspecCopyWithImpl<_Pubspec>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_PubspecToJson(this);
  }
}

abstract class _Pubspec implements PubSpec {
  factory _Pubspec(
      {Map<String, dynamic> dependencies,
      Map<String, dynamic> dependencyOverrides,
      String description,
      Map<String, dynamic> devDependencies,
      String documentation,
      Map<String, String> environment,
      Map<String, dynamic> executables,
      String homepage,
      String issueTracker,
      String name,
      String publishTo,
      String repository,
      String version}) = _$_Pubspec;

  factory _Pubspec.fromJson(Map<String, dynamic> json) = _$_Pubspec.fromJson;

  @override
  Map<String, dynamic> get dependencies;
  @override
  Map<String, dynamic> get dependencyOverrides;
  @override
  String get description;
  @override
  Map<String, dynamic> get devDependencies;
  @override
  String get documentation;
  @override
  Map<String, String> get environment;
  @override
  Map<String, dynamic> get executables;
  @override
  String get homepage;
  @override
  String get issueTracker;
  @override
  String get name;
  @override
  String get publishTo;
  @override
  String get repository;
  @override
  String get version;
  @override
  _$PubspecCopyWith<_Pubspec> get copyWith;
}

Dependency _$DependencyFromJson(Map<String, dynamic> json) {
  return _Dependency.fromJson(json);
}

/// @nodoc
class _$DependencyTearOff {
  const _$DependencyTearOff();

// ignore: unused_element
  _Dependency call(
      {String sdk, String version, Hosted hosted, dynamic git, String path}) {
    return _Dependency(
      sdk: sdk,
      version: version,
      hosted: hosted,
      git: git,
      path: path,
    );
  }

// ignore: unused_element
  Dependency fromJson(Map<String, Object> json) {
    return Dependency.fromJson(json);
  }
}

/// @nodoc
// ignore: unused_element
const $Dependency = _$DependencyTearOff();

/// @nodoc
mixin _$Dependency {
  String get sdk;
  String get version;
  Hosted get hosted;
  dynamic get git;
  String get path;

  Map<String, dynamic> toJson();
  $DependencyCopyWith<Dependency> get copyWith;
}

/// @nodoc
abstract class $DependencyCopyWith<$Res> {
  factory $DependencyCopyWith(
          Dependency value, $Res Function(Dependency) then) =
      _$DependencyCopyWithImpl<$Res>;
  $Res call(
      {String sdk, String version, Hosted hosted, dynamic git, String path});

  $HostedCopyWith<$Res> get hosted;
}

/// @nodoc
class _$DependencyCopyWithImpl<$Res> implements $DependencyCopyWith<$Res> {
  _$DependencyCopyWithImpl(this._value, this._then);

  final Dependency _value;
  // ignore: unused_field
  final $Res Function(Dependency) _then;

  @override
  $Res call({
    Object sdk = freezed,
    Object version = freezed,
    Object hosted = freezed,
    Object git = freezed,
    Object path = freezed,
  }) {
    return _then(_value.copyWith(
      sdk: sdk == freezed ? _value.sdk : sdk as String,
      version: version == freezed ? _value.version : version as String,
      hosted: hosted == freezed ? _value.hosted : hosted as Hosted,
      git: git == freezed ? _value.git : git as dynamic,
      path: path == freezed ? _value.path : path as String,
    ));
  }

  @override
  $HostedCopyWith<$Res> get hosted {
    if (_value.hosted == null) {
      return null;
    }
    return $HostedCopyWith<$Res>(_value.hosted, (value) {
      return _then(_value.copyWith(hosted: value));
    });
  }
}

/// @nodoc
abstract class _$DependencyCopyWith<$Res> implements $DependencyCopyWith<$Res> {
  factory _$DependencyCopyWith(
          _Dependency value, $Res Function(_Dependency) then) =
      __$DependencyCopyWithImpl<$Res>;
  @override
  $Res call(
      {String sdk, String version, Hosted hosted, dynamic git, String path});

  @override
  $HostedCopyWith<$Res> get hosted;
}

/// @nodoc
class __$DependencyCopyWithImpl<$Res> extends _$DependencyCopyWithImpl<$Res>
    implements _$DependencyCopyWith<$Res> {
  __$DependencyCopyWithImpl(
      _Dependency _value, $Res Function(_Dependency) _then)
      : super(_value, (v) => _then(v as _Dependency));

  @override
  _Dependency get _value => super._value as _Dependency;

  @override
  $Res call({
    Object sdk = freezed,
    Object version = freezed,
    Object hosted = freezed,
    Object git = freezed,
    Object path = freezed,
  }) {
    return _then(_Dependency(
      sdk: sdk == freezed ? _value.sdk : sdk as String,
      version: version == freezed ? _value.version : version as String,
      hosted: hosted == freezed ? _value.hosted : hosted as Hosted,
      git: git == freezed ? _value.git : git as dynamic,
      path: path == freezed ? _value.path : path as String,
    ));
  }
}

@JsonSerializable()

/// @nodoc
class _$_Dependency implements _Dependency {
  _$_Dependency({this.sdk, this.version, this.hosted, this.git, this.path});

  factory _$_Dependency.fromJson(Map<String, dynamic> json) =>
      _$_$_DependencyFromJson(json);

  @override
  final String sdk;
  @override
  final String version;
  @override
  final Hosted hosted;
  @override
  final dynamic git;
  @override
  final String path;

  @override
  String toString() {
    return 'Dependency(sdk: $sdk, version: $version, hosted: $hosted, git: $git, path: $path)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Dependency &&
            (identical(other.sdk, sdk) ||
                const DeepCollectionEquality().equals(other.sdk, sdk)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality()
                    .equals(other.version, version)) &&
            (identical(other.hosted, hosted) ||
                const DeepCollectionEquality().equals(other.hosted, hosted)) &&
            (identical(other.git, git) ||
                const DeepCollectionEquality().equals(other.git, git)) &&
            (identical(other.path, path) ||
                const DeepCollectionEquality().equals(other.path, path)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(sdk) ^
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(hosted) ^
      const DeepCollectionEquality().hash(git) ^
      const DeepCollectionEquality().hash(path);

  @override
  _$DependencyCopyWith<_Dependency> get copyWith =>
      __$DependencyCopyWithImpl<_Dependency>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_DependencyToJson(this);
  }
}

abstract class _Dependency implements Dependency {
  factory _Dependency(
      {String sdk,
      String version,
      Hosted hosted,
      dynamic git,
      String path}) = _$_Dependency;

  factory _Dependency.fromJson(Map<String, dynamic> json) =
      _$_Dependency.fromJson;

  @override
  String get sdk;
  @override
  String get version;
  @override
  Hosted get hosted;
  @override
  dynamic get git;
  @override
  String get path;
  @override
  _$DependencyCopyWith<_Dependency> get copyWith;
}

GitClass _$GitClassFromJson(Map<String, dynamic> json) {
  return _GitClass.fromJson(json);
}

/// @nodoc
class _$GitClassTearOff {
  const _$GitClassTearOff();

// ignore: unused_element
  _GitClass call({String path, String ref, String url}) {
    return _GitClass(
      path: path,
      ref: ref,
      url: url,
    );
  }

// ignore: unused_element
  GitClass fromJson(Map<String, Object> json) {
    return GitClass.fromJson(json);
  }
}

/// @nodoc
// ignore: unused_element
const $GitClass = _$GitClassTearOff();

/// @nodoc
mixin _$GitClass {
  String get path;
  String get ref;
  String get url;

  Map<String, dynamic> toJson();
  $GitClassCopyWith<GitClass> get copyWith;
}

/// @nodoc
abstract class $GitClassCopyWith<$Res> {
  factory $GitClassCopyWith(GitClass value, $Res Function(GitClass) then) =
      _$GitClassCopyWithImpl<$Res>;
  $Res call({String path, String ref, String url});
}

/// @nodoc
class _$GitClassCopyWithImpl<$Res> implements $GitClassCopyWith<$Res> {
  _$GitClassCopyWithImpl(this._value, this._then);

  final GitClass _value;
  // ignore: unused_field
  final $Res Function(GitClass) _then;

  @override
  $Res call({
    Object path = freezed,
    Object ref = freezed,
    Object url = freezed,
  }) {
    return _then(_value.copyWith(
      path: path == freezed ? _value.path : path as String,
      ref: ref == freezed ? _value.ref : ref as String,
      url: url == freezed ? _value.url : url as String,
    ));
  }
}

/// @nodoc
abstract class _$GitClassCopyWith<$Res> implements $GitClassCopyWith<$Res> {
  factory _$GitClassCopyWith(_GitClass value, $Res Function(_GitClass) then) =
      __$GitClassCopyWithImpl<$Res>;
  @override
  $Res call({String path, String ref, String url});
}

/// @nodoc
class __$GitClassCopyWithImpl<$Res> extends _$GitClassCopyWithImpl<$Res>
    implements _$GitClassCopyWith<$Res> {
  __$GitClassCopyWithImpl(_GitClass _value, $Res Function(_GitClass) _then)
      : super(_value, (v) => _then(v as _GitClass));

  @override
  _GitClass get _value => super._value as _GitClass;

  @override
  $Res call({
    Object path = freezed,
    Object ref = freezed,
    Object url = freezed,
  }) {
    return _then(_GitClass(
      path: path == freezed ? _value.path : path as String,
      ref: ref == freezed ? _value.ref : ref as String,
      url: url == freezed ? _value.url : url as String,
    ));
  }
}

@JsonSerializable()

/// @nodoc
class _$_GitClass implements _GitClass {
  _$_GitClass({this.path, this.ref, this.url});

  factory _$_GitClass.fromJson(Map<String, dynamic> json) =>
      _$_$_GitClassFromJson(json);

  @override
  final String path;
  @override
  final String ref;
  @override
  final String url;

  @override
  String toString() {
    return 'GitClass(path: $path, ref: $ref, url: $url)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _GitClass &&
            (identical(other.path, path) ||
                const DeepCollectionEquality().equals(other.path, path)) &&
            (identical(other.ref, ref) ||
                const DeepCollectionEquality().equals(other.ref, ref)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(path) ^
      const DeepCollectionEquality().hash(ref) ^
      const DeepCollectionEquality().hash(url);

  @override
  _$GitClassCopyWith<_GitClass> get copyWith =>
      __$GitClassCopyWithImpl<_GitClass>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_GitClassToJson(this);
  }
}

abstract class _GitClass implements GitClass {
  factory _GitClass({String path, String ref, String url}) = _$_GitClass;

  factory _GitClass.fromJson(Map<String, dynamic> json) = _$_GitClass.fromJson;

  @override
  String get path;
  @override
  String get ref;
  @override
  String get url;
  @override
  _$GitClassCopyWith<_GitClass> get copyWith;
}

Hosted _$HostedFromJson(Map<String, dynamic> json) {
  return _Hosted.fromJson(json);
}

/// @nodoc
class _$HostedTearOff {
  const _$HostedTearOff();

// ignore: unused_element
  _Hosted call({String name, String url}) {
    return _Hosted(
      name: name,
      url: url,
    );
  }

// ignore: unused_element
  Hosted fromJson(Map<String, Object> json) {
    return Hosted.fromJson(json);
  }
}

/// @nodoc
// ignore: unused_element
const $Hosted = _$HostedTearOff();

/// @nodoc
mixin _$Hosted {
  String get name;
  String get url;

  Map<String, dynamic> toJson();
  $HostedCopyWith<Hosted> get copyWith;
}

/// @nodoc
abstract class $HostedCopyWith<$Res> {
  factory $HostedCopyWith(Hosted value, $Res Function(Hosted) then) =
      _$HostedCopyWithImpl<$Res>;
  $Res call({String name, String url});
}

/// @nodoc
class _$HostedCopyWithImpl<$Res> implements $HostedCopyWith<$Res> {
  _$HostedCopyWithImpl(this._value, this._then);

  final Hosted _value;
  // ignore: unused_field
  final $Res Function(Hosted) _then;

  @override
  $Res call({
    Object name = freezed,
    Object url = freezed,
  }) {
    return _then(_value.copyWith(
      name: name == freezed ? _value.name : name as String,
      url: url == freezed ? _value.url : url as String,
    ));
  }
}

/// @nodoc
abstract class _$HostedCopyWith<$Res> implements $HostedCopyWith<$Res> {
  factory _$HostedCopyWith(_Hosted value, $Res Function(_Hosted) then) =
      __$HostedCopyWithImpl<$Res>;
  @override
  $Res call({String name, String url});
}

/// @nodoc
class __$HostedCopyWithImpl<$Res> extends _$HostedCopyWithImpl<$Res>
    implements _$HostedCopyWith<$Res> {
  __$HostedCopyWithImpl(_Hosted _value, $Res Function(_Hosted) _then)
      : super(_value, (v) => _then(v as _Hosted));

  @override
  _Hosted get _value => super._value as _Hosted;

  @override
  $Res call({
    Object name = freezed,
    Object url = freezed,
  }) {
    return _then(_Hosted(
      name: name == freezed ? _value.name : name as String,
      url: url == freezed ? _value.url : url as String,
    ));
  }
}

@JsonSerializable()

/// @nodoc
class _$_Hosted implements _Hosted {
  _$_Hosted({this.name, this.url});

  factory _$_Hosted.fromJson(Map<String, dynamic> json) =>
      _$_$_HostedFromJson(json);

  @override
  final String name;
  @override
  final String url;

  @override
  String toString() {
    return 'Hosted(name: $name, url: $url)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Hosted &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(url);

  @override
  _$HostedCopyWith<_Hosted> get copyWith =>
      __$HostedCopyWithImpl<_Hosted>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_HostedToJson(this);
  }
}

abstract class _Hosted implements Hosted {
  factory _Hosted({String name, String url}) = _$_Hosted;

  factory _Hosted.fromJson(Map<String, dynamic> json) = _$_Hosted.fromJson;

  @override
  String get name;
  @override
  String get url;
  @override
  _$HostedCopyWith<_Hosted> get copyWith;
}
